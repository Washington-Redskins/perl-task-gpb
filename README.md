Возможные инциденты, которые могут возникнуть в процессе увеличения строк > миллиона:
-при возростании количество кортежей запросы могут обрабатываться менее эффективно при последовательном сканировании (замедление выборки данных) и при отсутствии правильно сконфигурированной индексации. Что вызывет прямую зависимость на возрастание времени отклика. 
-если система будет иметь возможность работы с транзакциями (например, будет задействована подсистема InnoDB), то при определенных уровнях изоляции (SERIALIZABLE, READ COMMITTED, REPETABLE READ), могут возникнуть длительные блокировки/взаимоблокировки/конкуренция за строки.
-так же могут быть ограничения, вызванные недостаточным объемом оперативной памяти, в связи с чем могут возникнут проблемы производительности, такие как медленная обработка данных (например, вследсвтии swapping'a), полная или частичная деградация системы в целом, т.к. другие процессы в системе не будут получать требуемых ресурсов. 

1. В рамках решения потребуется произвести правильную индексацию в соответствии с используемыми запросами. В рамках представленного мною решения запрос на получения выборки по адресу представлен в виде:
SELECT message.created, message.str
FROM log
INNER JOIN message ON log.int_id = message.int_id
WHERE log.address = ?
ORDER BY message.created DESC
				 
Для оптимизации процесса поиска планировщиком можно добавить 2 сосатавных индексах:
CREATE INDEX idx_log_address_int_id ON log (address, int_id);
CREATE INDEX idx_message_int_id_created ON message (int_id, created);
Более эффективно, чем одичноые, с учетом текущего запроса, т.к. оба условия сортировки покрыты индексами - меньшье операций по вводу/ввыводу. Пскольку напрямую поддерживает условие where (log.address) и сортировку order by(message.created). Но это решение актуально только в рамках текущего задания при отсутствии других запросов, где бы данные поля могли задействоваваться в автономном порядке и рациональнее было использовать именно одичные индексы.


2. Затем можно было настроить партицировании таблицу по ключу address, либо по дате (created), как, например разбивая по месяцам. То есть обращаться лишь к одной секции, содержащей записи для этого адреса, игнорируя остальные. 

3. Можно "сэкономить" на размере индексных таблиц, индексируя только первые символы/префиксы.  Тогда индекс стане занимать меньше места, но, возможно, станет менее селективным.

4. Так же, возможен и другой вариант с индексами, а именно задействовать кластерные индексы по полю address, тогда для выборки всех сообщений одного адресата нужно будет прочитать с диска лишь небольшое кол-во страниц. Если же не использовать кластеризацию, то для каждого сообщения может задейстоваться отдельная операция дискового I/O. Но при этом это делает операции вставки и обновления более ресурсоемкими и становится критичным при большем объеме именно операций заииси. А так же не эффективно, когда требуется оптимизация по нескольким столбцам. Поэтому, если, например, фильтры не зависят от столбца address, то это так же может быть невыгодным решением.


5. Если архитектура, как в тестовом задании, не требует использования транзакций, можно рассмотреть подсистему MyISAM, где при включении параметра DELAY_KEY_WRITE, измененные индексные данные записываются сначала в буфер и лишь при заполнении будут выгружаться на диск, что позволит увеличить производительность работы с часто изменяемыми данными. 

6. Возможен вариант с покрывающими индексами, когда информация из таблицы записывается в сам индекс, тем самым избавляя от нужды просматривать саму таблицу. 
Покрывающие индексы значительно повышают производительность, так как записи индекса компактнее строк таблицы, что уменьшает объем обрабатываемых данных и операций ввода/вывода. Они занимают меньше места и лучше используют память, особенно в MyISAM, где индексы можно сжимать. Благодаря сортировке индексируемых значений поиск по диапазону выполняется быстрее, снижая обращения к диску.

7. В рамках текущей конфигурации весь результирующий набор из БД сохраняется в буфере на "клиентской" стороне, отправившей запрос, а затем передается прикладной библиотеке. Однако, например, если БД составляет значительные размеры, то потребляемый объем памяти можно сократить и приступить к обработке результата скорее, если задать режим работы без буферизации - mysql_use_result. Но при это увеличить время блокировки данных на самом сервере.

Действенность то или иного метода можно определить посредством профилирования как внутри самого кода (снимая соответсвующие тайминги), так и поредством функции протоколирования самого mysql. 
	 

https://github.com/Washington-Redskins/perl-task-gpb





